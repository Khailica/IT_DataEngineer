# 5. Циклы:
# 
# Задание 6
# Используя циклы, напишите код, который бы выводил данную фигуру:

         1
         21
         321  
         4321    
         54321     
         654321    
         7654321       
         87654321        
         987654321         
123456789 
 12345678   
  1234567 
   123456 
    12345 
     1234   
      123 
       12   
        1  

# Программа должна выводить фигуру разной величины, в зависимости от входного параметра.
# Значение параметра может принимать значения от 0 до 9.

# Решение:
amount = 10
n = 1
while n <= amount:
    for k in range(amount):
        print(" ", end="")
    # for i in range(n):
    #     print(i + 1, end="")
    for j in range(n, 1, -1):
        print(j - 1, end="")
    n += 1
    print()
n -= 1
while (amount - n) <= amount:
    n -= 1
    for k in range(amount - n):
        print(" ", end="")
    for i in range(n):
        print(i + 1, end="")
    # for j in range(n, 1, -1):
    #     print(j - 1, end="")
    print()



# 8. Строки:
#
# Задание 2
# Напишите код, который обрабатывает строковые данные и возвращает их с первыми заглавными буквами в каждом слове.

# Решение:
s = 'a1 2b  3   abc d3e r2D2'
for i in range(len(s)):
    if i == 0:
        print(s[i].upper(), end="")
    elif s[i].islower() is True and s[i-1].isspace() is True:
        print(s[i].upper(), end="")
    else:
        print(s[i], end="")


# Задание 3
# Пароль считается надежным, если его длина составляет не менее 12 символов,
# при этом он должен содержать хотя бы одну заглавную букву, хотя бы одну строчную букву, хотя бы одну цифру и хотя бы один спецсимвол.
# Напишите код, который обрабатывает строковые данные и выводит сообщение о том, надежен ли пароль или нет.
# В случае, если пароль не надежен, код должен выдавать рекомендации для усиления надежности пароля.
#
# Цифры, которые можно использовать для пароля: '1234567890'
#
# Строчные буквы, которые можно использовать для пароля: 'abcdefghijklmnopqrstuvwxyz'
#
# Заглавные буквы, которые можно использовать для пароля: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
#
# Спецсимволы, которые можно использовать для пароля: '!@#$%^&*()-+'

# Решение 1:
s = 'Qhefdwerdf1tY+'
if len(s) < 12:
    print('Слабый пароль. Рекомендации: увеличить число символов до 12')
elif all((i not in '1234567890') for i in s):
    print('Слабый пароль. Рекомендации: добавить 1 цифру')
elif all((i not in 'abcdefghijklmnopqrstuvwxyz') for i in s):
    print('Слабый пароль. Рекомендации: добавить 1 маленькую букву')
elif all((i not in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ') for i in s):
    print('Слабый пароль. Рекомендации: добавить 1 Заглавную букву')
elif all((i not in '!@#$%^&*()-+') for i in s):
    print('Слабый пароль. Рекомендации: добавить 1 спецсимвол')
elif any((i in '[~{}":;\']$_ ') for i in s):
    print('Ошибка. Запрещенный спецсимвол')
else:
    print('Сильный пароль.')

# Решение 2
s = 'Qhefdwerdf1tY+'
if len(s) < 12:
    print('Слабый пароль. Рекомендации: увеличить число символов до 12')
elif not set('1234567890').intersection(s):
    print('Слабый пароль. Рекомендации: добавить 1 цифру')
elif not set('abcdefghijklmnopqrstuvwxyz').intersection(s):
    print('Слабый пароль. Рекомендации: добавить 1 маленькую букву')
elif not set('ABCDEFGHIJKLMNOPQRSTUVWXYZ').intersection(s):
    print('Слабый пароль. Рекомендации: добавить 1 Заглавную букву')
elif not set('!@#$%^&*()-+').intersection(s):
    print('Слабый пароль. Рекомендации: добавить 1 спецсимвол')
elif set('[~{}":;\']$_ ').intersection(s):
    print('Ошибка. Запрещенный спецсимвол')
else:
    print('Сильный пароль.')



# 9. Списки:
#
# Задание 2
# Задан список с числами. Напишите программу, которая выводит все элементы списка, которые больше предыдущего, в виде отдельного списка.

# Решение:
list1 = [1, 5, 1, 5, 1]
list2 = [list1[i] for i in range(1, len(list1)) if list1[i-1] < list1[i]]
print(list2)


# Задание 3
# Задан список с числами. Напишите программу, которая меняет местами наибольший и наименьший элемент и выводит новый список.

# Решение:
list1 = [-5, 5, 10]
list2 = list1.copy()
var_max = list2[0]
mx = 0
var_min = list2[0]
mn = 0
for i in range(len(list1)):
    if var_max < list1[i]:
        var_max = list1[i]
        mx = i
        continue
    elif var_min > list1[i]:
        var_min = list1[i]
        mn = i
list2[mn] = var_max
list2[mx] = var_min
print(list2)



# 11. Словари:
#
# Задание 1
# Задан словарь. Напишите программу, которая будет выводить значение по заданному ключу.

# Решение:
dct = {'Hello': 'Hi', 'Bye': 'Goodbye', 'List': 'Array'}
k = input('Введите ключ')
print(dct[k])
print(dct.get(k))


# Задание 2
# Напишите программу, которая будет выполнять действие, обратное заданию 1.
# Программа должна производить поиск по значению и выдавать ключ.

# Решение:
dct = {'Hello': 'Hi', 'Bye': 'Goodbye', 'List': 'Array'}
value = input('Введите значение')
for k, v in dct.items():
    if v == value:
        print(k)


# Задание 3
# Напишите программу, которая принимает список строк и выводит количество повторений данных строк в списке.

# Решение:
lst = ['abc', 'bcd', 'abc', 'abd', 'abd', 'dcd', 'abc']
dct = dict.fromkeys(lst, 0)
for key in lst:
    dct[key] += 1
print(dct)




# 12. Множества:
#
# Задание 2
# Даны два списка чисел. Напишите программу, которая определяет, сколько в них встречается общих чисел, используя множества.

# Решение:
list1 = [1, 2, 3, 4, 5, 6, 7]
list2 = [10, 2, 3, 4, 8]
# st = set(list1).intersection(set(list2))
st = set(list1) & set(list2)
print(len(st))


# Задание 3
# Даны два множества чисел. Напишите программу, которая определяет, является ли первое множество подмножеством второго.
# Множество является подмножеством другого множества, если все данные первого совпадают с частью данных из второго.
# Если множества совпадают, они не являются подмножествами друг друга

# Решение:
st1 = {1, 2, 3, 4, 5, 6, 7}
st2 = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
print(st1 < st2)




# 15. Работа с файлами:
# Задание 1
# Вам, как сотруднику IT отдела, необходимо создать каждому сотруднику, переходящему в новый филиал, свой уникальный почтовый адрес.
# У вас есть неотформатированный список сотрудников, который заполняли непонятно как.
# Также у вас есть кусок кода - функция, которая по имени и фамилии сотрудника составляет его уникальный почтовый адрес.
# Для выполнения данного задания вам необходимо написать программу, удовлетворяющую следующим требованиям:
#
# 1) Программа должна читать исходный текстовый файл
#
# 2) Программа должна содержать функцию, представленную ниже, для создания почтовых адресов
#
# 3) Программа должна заполнить пустой столбец с почтовыми адресами в исходном файле и перезаписать его
#
# 4) Почтовый адрес должен создаваться только для тех, у кого заполнены все остальные поля - Имя, Фамилия, Телефонный номер, Город
#
# 5) Телефонный номер считается валидным, если он состоит из 7 цифр,
# в противном случае информация невалидна и программа не должна создавать почтовый адрес сотруднику
#
# После выполнения вашей программы исходный текстовый файл должен быть заполнен информацией с почтовыми адресами сотрудников. 


# Решение:
def email_gen(list_of_names):
    emails = []
    for i in list_of_names:
        letter = 1
        while i[1] + '.' + i[0][0:letter] + '@company.io' in emails:
            letter += 1
        emails.append(i[1] + '.' + i[0][0:letter] + '@company.io')
    return emails


f = open(file='/Users/frank/Documents/LEARNING IT, Eng, עברית/IT Data Engineer/Courses/Sber - '
              'Data_Engineer/Phyton/task_file.txt', mode='rt')

#  Создание пустых списков
nums = []
list_names = []
email = []
novalid = ['', 'NO_NAME', 'sfewrfw', 'dwfef', '0000000']

#  Использовать построчный итератор файла
for line in f:
    # Конвертировать строку line в список строк
    lines = line.split(', ')  # разбить строку line на подстроки lines
    lst = []  # временный список

    # обход элементов в строке
    for element in lines:
        element = element.rstrip(' \n\r')  # отсечь символ '\n'
        lst += [element]  # взять отдельный элемент добавить к списку
    if lst[1] not in novalid \
            and lst[2] not in novalid \
            and lst[3] not in novalid \
            and lst[4] not in novalid \
            and len(lst[3]) == 7:  # убрать из списка лишнее по условию
        nums = nums + [lst]  # добавить список к результирующему списку
        list_names += [lst[1:3]]
        print(lst)

email = email_gen(list_names)

fw = open(file='/Users/frank/Documents/LEARNING IT, Eng, עברית/IT Data Engineer/Courses/Sber - '
               'Data_Engineer/Phyton/task_file_new.txt', mode='w')

S = ', '  # разделитель, для последующей сборки строки
fw.write('EMAIL, NAME, LAST_NAME, TEL, CITY\n')  # вывод заголовка в файл
for k in range(1, len(nums)):
    nums[k][0] = email[k]
    fw.write(S.join(nums[k]) + '\n')  # сборка строки с разделителем S и запись в файл
    print(nums[k])
f.close()
fw.close()




# 16. Подключение модулей:
# Задание 1
# Необходимо написать функцию, которая будет генерировать тот самый надежный пароль случайным образом.
# Модуль random как раз поможет вам в этом. Давайте вспомним когда пароль считается надежным:
#
# 1) Пароль содержит не менее 12 символов
#
# 2) Пароль содержит хотя бы одну заглавную букву
#
# 3) Пароль содержит хотя бы одну строчную букву
#
# 4) Пароль содержит хотя бы одну цифру
#
# 5) Пароль содержит хотя бы один спецсимвол


# Решение:
import random


def passw(length=10):
    lst = ''
    for i in range(length):
        lst += random.choice('abcdefghijklmnopqrstuvwxyz'
                             + '1234567890'
                             + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                             + '!@#$%^&*()-+')
    return ''.join(lst)

try:
    print(passw(int(input('Введите длину пароля:'))))
except ValueError:
    print('неправильный ввод - ожидается целое положительное число')





# Сравнение операций:
# Написать программу, которая принимает от пользователя символ операции "+" или "*",
# затем запрашивает два целых числа и выводит результат выбранной математической операции с этими числами.
# Иначе выводится ошибка: "operation unknown".

# Решение 1:
try:
    operation = input("operation: ")
    line1 = input("integer number1:")
    line2 = input("integer number2:")
    number1 = int(line1)
    number2 = int(line2)
    if operation == "+":
        print(number1 + number2)
    elif operation == "*":
        print(number1 * number2)
    else:
        print('operation unknown')
except ValueError:
    print('operation unknown')


# Решение 2:
try:
    operation = input("operation: ")
    number1 = input("integer number1:")
    number2 = input("integer number2:")
    if operation in "+*":
        line = number1 + operation + number2
        expr = eval(line)  # очень опасная функция
        print(expr)
    else:
        print('operation unknown')
except ValueError:
    print('operation unknown')




# Функция приветствия:
# Напишите функцию, которая принимает от пользователя имя и выводит сообщение в формате: "Hello, <name> !"


# Решение:
def show_hello_name(name):
    print("Hello, ", name, "!", sep='')

name = input("name = ")
show_hello_name(name)




# Проверка числа на четность:
# Напишите функцию, которая проверяет, является ли указанный числовой аргумент четным (True) или нет (False),
# и выведите соответствующее значение на экран. Числовой аргумент получите от пользователя.


# Решение:
def is_even(number, even=None):
    if number % 2 == 0:
        even = True
    else:
        even = False
    return even

number = int(input("number = "))
print("number is even to 2:", is_even(number))




# Замена букв:
# В слове "антананариву" вместо буквы "а" выведите "о", используя цикл for и условный оператор if.

# Решение:
for symbol in 'антананариву':
    if symbol == 'а':
        print('о', end='')
    else:
        print(symbol, end='')




# Шахматная доска:
# Нарисуйте шахматную доску n на n из нулей и единиц. Верхний левый символ должен быть единицей

# Решение:
n = int(input('введите n:'))
m1 = 0
m2 = 1
for i in range(n):
    m1 = m2
    for j in range(n):
        if m1 == 0:
            print('0', end='')
            m1 = 1
        elif m1 == 1:
            print('1', end='')
            m1 = 0
    print()
    if m2 == 0:
        m2 = 1
    elif m2 == 1:
        m2 = 0



# Графика:
# Выведите пирамиду заданной высоты, состоящую из символов * . Значение высоты вводится пользователем.
# Важно соблюдать увеличение количества звезд в зависимости от высоты, а также правильно центрировать звездочки.

# Решение:
n = int(input('введите n:'))
m = 1
for i in range(1, n+1):
    print(' ' * (n-i), '*' * m, ' ' * (n-i), sep='')
    m += 2




# Маленькое произведение:
# Даны два натуральных числа a и b (известно, что b больше, чем a).
# Вывести наибольшее кол-во чисел, входящих в промежуток [a, b], произведение которых не превышает произведения чисел a и b.

# Решение:
import sys

a = int(input('a:'))
b = int(input('b:'))
if a == 0 or b == 0:
    print(0)
    sys.exit()
n = 1
mult = a
for i in range(a + 1, b + 1):
    mult *= i
    # print(i - 1, i, 'mult:', mult, 'a*b =', a * b)
    if mult <= (a * b):
        n += 1
        # print('n:', n)
    else:
        break
print(n)




# Поиск элемента:
# Напишите функцию slice_tup(), которая принимает на вход кортеж и некоторый элемент, а возвращает кортеж,
# начиная с первого вхождения этого элемента и далее. Если элемента в кортеже нет, то возвращается исходный кортеж.

# Решение:
def slice_tup(tup, el):
    try:
        ind = tup.index(el)
        return tup[ind:]
    except ValueError:
        return tup[:]
print(slice_tup((1, 2, 3, 4), 2))
print(slice_tup(('a', 'b', 'c', 'd'), 'd'))
print(slice_tup((1, 2, 3, 4), 5))
print(slice_tup(('a', 'b', 'c', 'd'), 'a'))




# Печать алфавита:
# Напишите программу, которая создает словарь alphabet, ключами которого являются русские строчные буквы,
# а значениями --- порядковые номера букв в алфавите, начиная с 1.
# Программа ничего выводить не должна, правильность заполнения словаря будет проверена автоматически.

# Решение 1:
russian = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
alphabet = dict.fromkeys([n for n in russian])
i = 1
for x in alphabet:
    alphabet[x] = i
    i += 1
print(alphabet)


# Решение 2:
russian = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
alphabet = dict(zip([n for n in russian], [m for m in range(1, len(russian) + 1)]))
print(alphabet)




# Анаграммы:
# Анаграммой строки S1 называется строка S2, которая получается из строки S1 путем перестановки символов.
# На входе программа получает две строки: S1 и S2. Ваша задача выяснить, является ли строка S2 анаграммой строки S1.
# Выведите YES, если является, и NO, если не является.

# Решение:
s1, s2 = input(), input()
if len(s1) == len(s2) and set(s1) == set(s2):
    print('YES')
else:
    print('NO')




# Азбука Морзе:
# Вам дан английский текст. Закодируйте его с помощью азбуки Морзе. Каждая буква заменяется на последовательность точек и тире.
# В качестве тире используйте обычный дефис «-», а в качестве точки — точку «.». Например, буква «g» превратится в трёхсимвольную строку «--.».
# Ниже в переменной morze для вашего удобства хранится словарь соответствия английских букв коду Морзе.
# Входные данные Весь текст записан в единственной строке. Текст состоит из английских букв и пробелов, других символов в тексте нет.
# В тексте не может быть двух или более пробелов подряд.
# Выходные данные Выведите каждое слово исходного текста, закодированное азбукой Морзе, на отдельной строке.
# Количество строк в ответе должно совпадать с количеством слов в исходном тексте.
# Между закодированными буквами ставится ровно один пробел. Например, слово «Help» превратится в «.... . .-.. .--.». 
# Обратите внимание, что строчные и заглавные буквы кодируются одинаково.

# Решение:
morze = {'a': '•—', 'b': '—•••', 'c': '—•—•', 'd': '—••',
         'e': '•', 'f': '••—•', 'g': '——•', 'h': '••••',
         'i': '••', 'j': '•———', 'k': '—•—', 'l': '•—••',
         'm': '——', 'n': '—•', 'o': '———', 'p': '•——•',
         'q': '——•—', 'r': '•—•', 's': '•••', 't': '—',
         'u': '••—', 'v': '•••—', 'w': '•——', 'x': '—••—',
         'y': '—•——', 'z': '——••'}
txt = input('Введите текст:').lower() + ' '

for i in range(len(txt) - 1):
    if txt[i + 1] == ' ':
        print(morze.get(txt[i]), end='')
    elif txt[i] == ' ':
        print()
    else:
        print(morze.get(txt[i]), end=' ')




# Количество уникальных элементов:
# Перед вами два списка. Посчитайте разность количества уникальных элементов этих двух списков и выведите ее на экран.
# Разность возьмите по модулю, воспользовавшись функцией abs().

# Решение:
a = [int(x) for x in input().split(',')]
b = [int(x) for x in input().split(',')]
len_set_a = len(set(a))
len_set_b = len(set(b))
print(len_set_a)
print(len_set_b)
print(abs(len_set_b - len_set_a))




# Прошлые встречи:
# Вовходной строке записана последовательность чисел через пробел. Для каждого числа выведите слово YES (в отдельной строке), 
# если это число ранее встречалось в последовательности, или NO, если не встречалось.

# Решение:
a = input('введите последовательность:').split()
for i in range(len(a)):
    if a[i] in a[:i]:
        print('YES', end=' ')
    else:
        print('NO', end=' ')




# Замена элемента:
# Поменяйте все значения матрицы matrix 5х5 с нулевыми значениями на значение 1 по главной диагонали:

# Решение:
matrix = [[0 for i in range(5)] for j in range(5)]
for i in range(5):
    matrix[i][i] = 1
print(matrix)




# Обменный курс:
# В одном тугрике 17 чогриков, а в одном чогрике 13 песо.
# Определите, на какое число тугриков и чогриков можно разменять n песо, если провести все возможные разменные операции?
# На вход программа получает одно натуральное число, а в качестве результата ожидается три натуральных числа, разделенные пробелом:
# число тугриков, число чогриков, число оставшихся песо

# Решение:
pes = int(input('n:'))
tg = divmod(pes, 13 * 17)
# print(tg)
ch = divmod(tg[1], 13)
# print('ch', ch)

print(tg[0], ch[0], ch[1])




# Разворот:
# Используя метод pop, создайте и выведите на экран список в обратном порядке.
# Навход программа получает список чисел, разделенных пробелами, на выходе должна вывести список чисел в обратном порядке

# Решение:
lst = list(map(int, input('list:').split()))
# print(lst)
lst_inv = []
l = len(lst)
for i in range(l):
    lst_inv.append(lst.pop())
    # lst_inv.append(lst[l - 1 - i])  # второй способ
print(lst_inv)





# Начало и конец:
# Среди всех вхождений элемента в список найдите то, которое расположено ближе всего к началу или концу списка.
# Если искомое вхождение равноудалено от начала и конца, выведите индекс, который ближе к началу.
# Если элемента в списке нет, выведите -1. На вход программе подается две строки.
# В первой строке находится число, индекс которого нужно найти, во второй строке находится список чисел, разделенных пробелами.

# Решение:
l = input('Введине значение:')
lst = input('Введите список:').replace(' ', '')
l_first = lst.find(l)
l_last = lst.rfind(l)
l_end = len(lst) - l_last
# print(l_first, l_last, l_end)
if l_first < l_end:
    print(l_first)
elif l_end < l_first:
    print(l_last)
else:
    print(-1)
    




# Маленькие делители:
# Напишите функцию, которая на входе получает два числа и возвращает все делители первого числа, не превосходящие второе число.
# На вход программе подаются два числа, разделенных пробелом. На выходе программа должна напечатать список делителей, удовлетворяющих условию

# Решение:
def find_divisors(a, b):
    lst = []
    for i in range(1, b):
        if a % i == 0:
            lst.append(i)
    return lst


a, b = map(int, input('Введите два числа:').split(' '))
print(find_divisors(a, b))





# Разбиение на группы:
# На вход программа получает две строки. В первой находится список целых чисел, разделенных пробелом.
# Во второй строке программа получает натуральное число group_size.
# Программа должна определить, можно ли полученный список разделить на группы размера group_size так,
# чтобы в каждой группе все элементы были одинаковы. На выходе программа должна вывести True или False

# Решение:
lst = list(map(int, input('Введите список:').split(' ')))
group_size = int(input('Введине значение:'))
if len(set(lst)) % group_size == 0 and len(lst) % group_size == 0:
    print(True)
else:
    print(False)





# Каждый на своем месте:
# Выведите элементы списка, у которых индекс в отсортированном по возрастанию списке не меньше, чем значение.
# На вход программа получает список целых чисел, разделенных пробелом.
# На выходе программа должна вывести список подходящих элементов

# Решение:
lst = list(map(int, input('Введите список:').split(' ')))
sort_lst = sorted(lst)
lst_out = []
for i in range(len(sort_lst)):
    if i >= sort_lst[i]:
        lst_out.append(sort_lst[i])
print(lst_out)





# Длина ломаной:
# Расстояние между двумя точками в евклидовой метрике вычисляется как корень из суммы квадратов разностей соответствующих координат.
# (Например, квадрат расстояния между точками (1, 2) и (4, 6) равен (4-1)(4-1)+(6-2)(6-2)=25, а значит, само расстояние равно 5.)
# Вычислите длину ломаной в евклидовой метрике на плоскости. На вход программа получает две строки с числами, разделенными пробелами.
# Первая строка содержит координаты точек по оси абсцисс, вторая строка содержит координаты точек по оси ординат.

# Решение:
lst_a = list(map(int, input('Введите список a:').split(' ')))
lst_b = list(map(int, input('Введите список b:').split(' ')))
l = 0
for i in range(len(lst_a) - 1):
    l += ((lst_b[i+1] - lst_b[i])**2 + (lst_a[i+1] - lst_a[i])**2)**0.5
print('{:.2f}'.format(l))





# Наибольший модуль:
# Найдите в списке два элемента, произведение которых является наибольшим по модулю.
# На вход программа получает список целых чисел, разделенных пробелами. На выходе программа должна напечатать число

# Решение 1:
lst = list(map(int, input('Введите список a:').split(' ')))
n = 0
lst_max = []
while n <= 1:
    max1 = max(lst)
    min1 = min(lst)
    # print(min1, max1)
    if max1 > -min1:
        lst_max.append(lst.pop(lst.index(max1)))
    else:
        lst_max.append(lst.pop(lst.index(min1)))
    n += 1
    # print(lst)
print(lst_max[0] * lst_max[1])

# Решение 2:
# но не работает с отрицательными числами
lst = list(map(int, input('Введите список a:').split(' ')))
lst_sort = sorted(map(abs, lst))
print(lst_sort[-1] * lst_sort[-2])





# Буквенное расстояние:
# Определим буквенное расстояние между двумя строками как сумму модулей разностей количества вхождений букв в этих строках.
# (Например, буквенное расстояние между строками 'abcde' и 'aaaee' равно 6: буквы a, b, c ,d ,e входят в первую строку по одному разу,
# во вторую строку входят три буквы a и две буквы e; тогда буквенное расстояние равно (3 - 1) + (1 - 0) + (1 - 0) + (1 - 0) + (2 - 1) = 6.)
# Найдите буквенное расстояние между двумя строками.
# На вход программа получает две строки, на выходе печатает натуральное число – буквенное расстояние между строками

# Решение:
str1 = input('Введите строку 1:')
str2 = input('Введите строку 2:')
letter_distance = 0

for i in str1:
    letter_distance += abs(str1.count(i) - str2.count(i))
    str1 = str1.replace(i, '')
    str2 = str2.replace(i, '')

for i in str2:
    letter_distance += abs(str1.count(i) - str2.count(i))
    str1 = str1.replace(i, '')
    str2 = str2.replace(i, '')

print(letter_distance)





# Повторение – мать учения:
# В программе задан список lst. На вход программе подаются три целых числа insert_index, number_to_insert, number_insertions, разделенных пробелом.
# Вставьте в список lst число number_to_insert на позицию insert_index number_insertions раз и выведите список на экран

# Решение:
insert_index, number_to_insert, number_insertions = \
    (map(int, input('введите число:').split()))
lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for i in range(number_insertions):
    lst.insert(insert_index, number_to_insert)
print(lst)